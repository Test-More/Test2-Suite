<dl class="listnav">
    <dt id="Overview">Overview</dt>
    <dd>
        <h2>Test2::Tools::Compare</h2>

        This package provides tools for verifying deep data structures.
        It also provides the Compare DSL functions.

        <script class="code">
            use Test2::Tools::Compare qw(
                is like isnt unlike
                match mismatch validator                        
                hash array bag object meta number string subset
                in_set not_in_set check_set
                item field call call_list call_hash prop check
                end filter_items
                T F D DNE FDNE
                exact_ref
            );

            # Shallow:
            is(  "apple", "apple", "strings are equivelent");
            like("apple", qr/ppl/, "string matches pattern");

            # And deep:
            is(  [1, 2, 3, 4], [1, 2, 3, 4], "arrays have the same contents");
            like([1, 2, 3, 4], [1, 2],       "first 2 array elements match");
        </script>

        See the <a href="https://metacpan.org/pod/Test2::Tools::Compare">module documentation</a> or the sub-nav items on the bottom left for more.
    </dd>

    <dt id="State">State</dt>
    <dd>
        <h2>Simple state checks</h2>

        These are some shortcuts for checking the state of vars or nested elements.

        <script class="code">
            # Loaded by default in Test2::V0
            use Test2::Tools::Compare qw{ T F D DNE FDNE };

            is(1, T(), "Check that we got a true value");
            is(0, F(), "Check that we got a false value");
            is(0, D(), "Check that we got a defined value");

            is([1], [1, DNE()],  "Check that the second array element does not exist");
            is({}, {a => DNE()}, "Check that the 'a' element does not exist");

            is(
                {a => 0},
                {a => FDNE(), b => FDNE()},
                "Check that a and b are false, or do not exist at all"
            );
        </script>

        T() and F() may be used in nested structures, the key/element
        must exist, but may be undefined for F().
    </dd>

    <dt id="Directed">Directed</dt>
    <dd>
        <h2>Directed checks</h2>

        <p><br />

        You have some control over what type of check is used:

        <p><br />
        <script class="code">
            # Loaded by default in Test2::V0
            use Test2::Tools::Compare qw{ match mismatch number string exact_ref };

            is("foo", match qr/oo/, "String matches pattern");

            is("foo", mismatch qr/aa/, 'String does not match pattern');

            is("12.00", number(12), "Use a numeric comparison");

            is($thing, string($thing), "use a string comparison");

            my $r = [];
            is(
                {a => $r},
                {a => exact_ref($r)},
                "ensure the 'a' key has the exact ref we want."
            );
        </script>

        <p>

        <ul>
            <li>These can all be nested as deep as you need.</li>
            <li>They can be used in is() and like().</li>
        </ul>
    </dd>

    <dt id="Custom">Custom</dt>
    <dd>
        <h2>Custom validators</h2>

        <p><br />
        <script class="code">
            # Loaded by default in Test2::V0
            use Test2::Tools::Compare qw{ validator };

            is(
                "foo",
                validator(sub { $_ eq 'foo' ? 1 : 0 }),
                "Check that string is foo"
            );

            my $validator = validator(
                "OP", "Check Foo",
                sub {
                    my %params = @_;

                    my $got      = $params{got};         # Same as $_
                    my $exists   = $params{exists};      # applies to keys and elements
                    my $operator = $params{operator};    # 'OP'
                    my $name     = $params{name};        # 'Check Foo'

                    ...

                    return $bool;
                }
            );
        </script>
    </dd>

    <dt id="Sets">Sets</dt>
    <dd>
        <h2>Checking sets</h2>

        <p><br />
        Check that the value matches 1 OR MORE of the specified checks.
        <script class="code">
            is('apple', in_set('pear', 'apple', 'orange'), "got a fruit");
        </script>

        <p><br />
        Check that the value DOES NOT match ANY of the specified checks.
        <script class="code">
            is('apple', not_in_set('dog', 'cat', 'cow'), "not an animal");
        </script>

        <p><br />
        Check that the value matches ALL of the specified checks.
        <script class="code">
            is('apple', not_in_set(match qr/pp/, match qr/a/), "matched both patterns");
        </script>
    </dd>

    <dt id="Array">Array</dt>
    <dd>
        <h2>Array Checks</h2>

        <ul>
            <li>Array checks let you declare an array.</li>
        </ul>

        <script class="code">
            is(
                [qw/foo bar baz bat/],
                array {
                    item 'foo';        # [0] First item is 'foo'
                    item match qr/a/;  # [1] second item matches /a/
                    item 3 => 'bat';   # [3] Skip right to index 3
                    end;               # Specify that there should be no more items.
                },
                "Array matches expectations"
            );
        </script>

        If we change the array, we can see how nice the diagnostics are:

        <script class="code">
            [qw/bad oops/]
        </script>

        <script class="output">
            not ok 1 - Array matches expectations
            # Failed test 'Array matcheds expectations'
            # at test.pl line 9.
            # +------+------------------+----+---------+------+
            # | PATH | GOT              | OP | CHECK   | LNs  |
            # +------+------------------+----+---------+------+
            # |      | ARRAY(0x850b58)  |    | <ARRAY> | 3, 8 |
            # | [0]  | bad              | eq | foo     | 4    |
            # | [1]  | oops             | =~ | (?^:a)  | 5    |
            # | [3]  | <DOES NOT EXIST> |    | bat     | 6    |
            # +------+------------------+----+---------+------+
            1..1
        </script>
    </dd>

    <dt id="Hash">Hash</dt>
    <dd>
        <h2>Hash Checks</h2>

        <ul>
            <li>Hash checks let you declare a hash.</li>
        </ul>

        <script class="code">
            is(
                {foo => 'foo', bar => 'bar'},
                hash {
                    field foo => 'foo';
                    field bar => match qr/a/;
                    end; # Specify that there should be no more elements.
                },
                "Hash matches expectations"
            );
        </script>

        If we change the hash, we can see how nice the diagnostics are:

        <script class="code">
            {apple => 'butter', foo => 'foops', bar => 'buurr'}
        </script>

        <script class="output">
            not ok 1 - Hash matches expectations
            # Failed test 'Hash matches expectations'
            # at test.pl line 8.
            # +---------+-----------------+---------+------------------+------+
            # | PATH    | GOT             | OP      | CHECK            | LNs  |
            # +---------+-----------------+---------+------------------+------+
            # |         | HASH(0x1ff7b58) |         | <HASH>           | 3, 7 |
            # | {foo}   | foops           | eq      | foo              | 4    |
            # | {bar}   | buurr           | =~      | (?^:a)           | 5    |
            # | {apple} | butter          | !exists | <DOES NOT EXIST> |      |
            # +---------+-----------------+---------+------------------+------+
        </script>
    </dd>

    <dt id="Meta">Meta</dt>
    <dd>
        <h2>Meta Checks</h2>

        <p>
        <br />
        Meta-checks give you the ability to check the properties of a
        value.

        <p>
        <br />
        <script class="code">
            is(
                $thing,
                meta {
                    prop blessed => 'My::Module'; # Ensure value is blessed as our package
                    prop reftype => 'HASH';       # Ensure value is a blessed hash
                    prop size    => 4;            # Key or element count
                    prop this    => ...;          # Check the item itself
                },
                "Thing matches expectations"
            );
        </script>

        <p>
        <br />
        meta() is a sub that takes a coderef as its only argument
        (prototype).

        <p>
        <br />

        The 4 properties above are available for any type of item.
        <br />
        <small>* Except size</small>
    </dd>

    <dt id="Object">Object</dt>
    <dd>
        <h2>Object checks</h2>
        <ul>
            <li>Object checks let you declare an object.</li>
            <li>Can use meta-check properties.</li>
            <li>Can use hash or array depending on the object.</li>
        </ul>

        <script class="code">
            is(
                bless({foo => 'foo', bar => 'bar'}, 'My::Package'),
                object {
                    # Meta properties:
                    prop blessed => 'My::Package';

                    # Can check fields on underlying hash
                    field foo => 'foo';
                    field bar => match qr/a/;

                    # Can check results of calling methods
                    call foo => 'foo';

                    # Can check results of calling custom methods
                    call sub {[shift->list]} => ['a', 'b', 'c'];
                },
                "Object is as expected"
            );
        </script>
    </dd>
</dl>
