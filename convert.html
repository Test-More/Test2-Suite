<dl class="listnav">
    <dt id="must_i">Must&nbsp;I?</dt>
    <dd>
        <h2>Do I need to convert?</h2>

        <b>Short Answer: No.</b>

        <br />
        <br />
        <br />
        <h3>Do I need the latest Test-Simple?</h3>

        No. You will only need to install the latest version if you need
        something it provides.

        <br />
        <br />
        <br />
        <h3>Do I need to change my existing tests?</h3>

        Most things will "just work"! Few test files need to be altered.
    </dd>

    <dt id="test_more">Test::More</dt>
    <dd>
        <dl class="sub_list">
            <dt id="Before">Before</dt>
            <dd>
                <h2>Before</h2>
                <script class="code">
                    # Load Test::More and set plan
                    use Test::More tests => #;

                    use_ok 'foo';
                    require_ok 'bar';

                    ok(1, 'simple ok');
                    is('foo', 'foo', 'simple is');
                    is_deeply({a => 1}, {a => 1}, "simple is_deeply");

                    # check $thing->isa('Base') or dump $thing
                    isa_ok($thing, 'Base',  "thing->isa(Base1)") || explain($thing);
                    isa_ok($thing, 'Base2', "thing->isa(Base2)") || explain($thing);

                    {
                        local $TODO = "fixme";
                        ok(0, "oops");
                    }

                    # Not required with a plan, but allowed
                    done_testing;
                </script>
            </dd>

            <dt id="After">After</dt>
            <dd>
                <h2>After</h2>
                <script class="code">
                    # Load Bundle, no planning at import
                    use Test2::Bundle::More;

                    use 'foo';      # use_ok is gone
                    require 'bar';  # require_ok is gone

                    ok(1, 'simple ok');
                    is('foo', 'foo', 'simple is');
                    is_deeply({a => 1}, {a => 1}, "simple is_deeply");

                    # isa_ok is now consistent with can_ok, all args after the
                    # first are classes
                    isa_ok($thing, 'Base1', 'Base2'); # explain() is gone

                    {
                        my $todo = todo "fixme";
                        ok(0, "oops");
                    }

                    # Not required with a plan, but allowed
                    done_testing;
                </script>
            </dd>

            <dt id="planning">Planning</dt>
            <dd>
                <h2>How to set the plan.</h2>

                You can no longer set the plan at import:

                <script class="code">
                    use Test::More tests => 5;
                    use Test::More skip_all => "Do not run";
                </script>

                Instead you must plan using a function:

                <script class="code">
                    use Test2::Bundle::More;
                    plan 5;
                    skip_all "Do not run";
                    done_testing;
                </script>

                Note that 'plan()' now only takes a single numeric value, and
                'skip_all()' is a separate function.
            </dd>

            <dt id="todo">Todo</dt>
            <dd>
                <h2>Todo is different</h2>

                '$TODO' is gone. Instead we have 'todo()'.

                <script class="code">
                    my $todo = todo "foo";
                    ...
                    $todo = undef; # End the todo
                </script>

                or

                <script class="code">
                    todo "foo" => sub {
                        ...
                    };
                    # End of todo
                </script>
            </dd>

            <dt id="Summary">Summary</dt>
            <dd>
                <h2>What is different?</h2>

                <b>Note:</b> Differences are only if you load
                Test2::Bundle::More. Test::More itself has not changed.

                <ul>
                    <li>Cannot plan at import</li>
                    <li>use_ok() is gone (use ok(...) still works)</li>
                    <li>require_ok() is gone</li>
                    <li>todo_skip() is gone</li>
                    <li>eq_array(), eq_hash(), and eq_set() are gone</li>
                    <li>explain() is gone</li>
                    <li>new_ok() is gone</li>
                    <li>isa_ok() takes different arguments</li>
                    <li>is_deeply() has better diagnostics</li>
                    <li>$TODO is replaced by todo()</li>
                </ul>
            </dd>
        </dl>
    </dd>

    <dt id="fennec">Fennec</dt>
    <dd>
        <dl class="sub_list">
            <dt id="Load">Load</dt>
            <dd>
                <h2>What to load?</h2>

                This will get you pretty much everything Fennec has:
                <script class="code">
                    use Test2::IPC;
                    use Test2::Bundle::Extended;
                    use Test2::Tools::Spec;
                </script>

                If you want the declarative syntax:
                <script class="code">
                    # This also loads the 3 packages above.
                    use Test2::Bundle::SpecDeclare;
                </script>

                <table>
                    <tr><th style="text-align: left">Test2::IPC</th>                <td>Make fork/threads work</td></tr>
                    <tr><th style="text-align: left">Test2::Bundle::Extended</th>   <td>Many tools</td></tr>
                    <tr><th style="text-align: left">Test2::Tools::Spec</th>        <td>SPEC tools</td></tr>
                    <tr><th style="text-align: left">Test2::Bundle::SpecDeclare</th><td>Declare syntax plugin (plus all the above)</td></tr>
                </table>
            </dd>

            <dt id="DreamHost">DreamHost</dt>
            <dd>
                <h2>What to load at DreamHost?</h2>

                <script class="code">
                    use Ndn::Test::Bundle;
                    # OR
                    use Ndn::Test::Bundle -target => 'Class::You::Are::Testing;
                </script>

                <ul>
                    <li>This will load Everything from the previous slide.</li>
                    <li>Maps Fennec env-vars to the Test2 ones.</li>
                    <li>Loads the DBHarness.</li>
                    <li>Loads the DB Fixture tools.</li>
                    <li>Loads other DH specific tools.</li>
                    <li>'-target' when given loads the specified module and sets '$CLASS' and 'CLASS()'</li>
                </ul>
            </dd>

            <dt id="Compare">Compare</dt>
            <dd>
                <h2>Comparing structures</h2>

                <ul>
                    <li>is_deeply() is gone, just use is().</li>
                    <li>like() can also check deep structures now.</li>
                </ul>

                <script class="code">
                    is('foo', 'foo', "foo");
                    is({foo => 1}, { foo => 1 }, "deep foo");

                    like('-foo-', qr/foo/, "like /foo/");
                    like({a => '-foo-'}, {a => qr/foo/}, "{a} like /foo/");

                    # Like only checks fields you specify, this will pass:
                    like(
                        {a => '-foo-', b => 'ignored', c => 'also ignored'},
                        {a => qr/foo/},    # We only care about {a}
                        "{a} like /foo/"
                    );
                </script>
            </dd>

            <dt id="mock1">Mocking</dt>
            <dd>
                <h2>Test2::Tools::Mock</h2>

                Test2::Tools::Mock replaces Mock::Quick.

                <script class="code">
                    use Test2::Tools::Mock;

                    my $c = mock 'Some::Class' => (
                        add => [
                            new_method => sub { ... },
                        ],
                        override => [
                            new   => sub { ... },
                            do_it => sub { ... },
                        ],
                        # Any method on Test2::Mock can be used as a key here.
                    );
                </script>

                <ul>
                    <li>mock() returns a control object, just like Mock::Quick.</li>
                    <li>Must specify override or add.</li>
                    <li>Control object has more capabilities.</li>
                    <li>One function for all mocking.</li>
                </ul>
            </dd>

            <dt id="Class">Mock-Class</dt>
            <dd>
                <h2>Mocking Classes</h2>

                This replaces both qtakeover() and qclass() from Mock::Quick.

                <script class="code">
                    # Quick way
                    my $c = mock 'Some::Class' => (...);

                    # Explicit way
                    my $c = mock 'class', 'Some::Class' => (...);

                    # Alternative
                    my $c = mock_class 'Some::Class' => (...); # Not exported by default

                    $c = undef;
                </script>

                <ul>
                    <li>If the first argument is a string other than 'obj' or 'class' it is treated as a package name.</li>
                    <li>making the first argument 'class' will force the next argument to be used as a package name.</li>
                    <li>mock_class() can also be used, but is not exported by default.</li>
                </ul>
            </dd>

            <dt id="Object">Mock-Object</dt>
            <dd>
                <h2>Mocking Objects</h2>

                Instead of qobj() and qmeth(), use mock().

                <script class="code">
                    my $obj = mock {attr1 => 1, attr2 => 2 } => (
                        add => [
                            foo => sub { 'foo' },
                        ],
                    );

                    $obj->xxx('123');
                    is($obj->xxx, 123, "Auto-vivify accessor");
                    is($obj->attr1, 1, "read/write accessor generated");
                    is($obj->foo, 'foo', "Custom accessor.");
                </script>

                You could also use mock_obj() (not exported by default).
            </dd>

            <dt id="SPEC">SPEC</dt>
            <dd>
                <h2>SPEC Workflow</h2>

                <div id="wf_code" style="float: left; width: 400px;">
                    <script class="code">
                        # Bind to scope
                        before_all  foo => sub { ... };
                        after_all   foo => sub { ... };
                        around_all  foo => sub { ... };

                        # Bind to cases
                        before_case foo => sub { ... };
                        after_case  foo => sub { ... };
                        around_case foo => sub { ... };

                        # Bind to tests
                        before_each foo => sub { ... };
                        after_each  foo => sub { ... };
                        around_each foo => sub { ... };

                        case a          => sub { ... };
                        case b          => sub { ... };
                        tests foo       => sub { ... };
                        describe nested => sub { ... };
                    </script>
                </div>

                <div style="float: left">
                    <ul>
                        <li>More clearly specified run order.</li>
                        <li>Does not fork for each test by default.</li>
                        <li>Mocking works, no need to keep the control object.</li>
                        <li>Can still run specific test. ($ENV{T2_WORKFLOW})</li>
                    </ul>
                </div>
            </dd>

            <dt id="Declare">Declare</dt>
            <dd>
                <h2>Declarative Syntax</h2>

                <script class="code">
                    # Mark a block as TODO
                    tests foo(todo => "why") { ... }

                    # Mark a block to be skipped
                    tests foo(skip => "why") { ... }

                    # Block may be run concurrently (fork or thread) or in serial
                    tests foo(async => 1) { ... }

                    # Block must be run in isolation (fork or thread, parent waits)
                    tests foo (iso => 1) { ... }

                    # Block must be run in isolation, can also run concurrently
                    # (What Fennec did)
                    tests foo (iso => 1, async => 1) { ... };
                </script>
            </dd>

        </dl>
    </dd>

    <dt id="breakage">Breakage</dt>
    <dd>
        <dl class="sub_list">
            <dt id="overview">Overview</dt>
            <dd>
                <h2>Overview of what breaks</h2>

                <dl>
                    <dt>Replacing the Test::Builder singleton</dt>
                    <dd style="margin-bottom: 10px">
                        Some test tools re-blessed or replaced the
                        Test::Builder singleton. This is not supported.
                    </dd>

                    <dt>Direct hash access to the singleton</dt>
                    <dd style="margin-bottom: 10px">
                    Some tools directly accessed the values of the singleton
                    hashref. Many of the old hash keys are now gone.
                    </dd>

                    <dt>Some private methods on the singleton</dt>
                    <dd style="margin-bottom: 10px">
                        Some private (underscore) methods have been removed.
                    </dd>

                    <dt>Monkey Patching</dt>
                    <dd style="margin-bottom: 10px">
                        A lot of effort was made to allow existing
                        monkeypatching to work, but not all survived.
                    </dd>
                </dl>
            </dd>

            <dt id="modules">Modules</dt>
            <dd>
                <h2>Modules known to be broken</h2>

                <table>
                    <tr><th>Module</th><th>Verson</th><th>Fixed?</th></tr>
                    <tr><td>Test::Exception</td>               <td>0.42</td> <td>YES</td></tr>
                    <tr><td>Test::SharedFork</td>              <td>0.34</td> <td>YES</td></tr>
                    <tr><td>Test::Clustericious::Cluster</td>  <td>0.30</td> <td>YES</td></tr>
                    <tr><td>Test::Alien</td>                   <td>0.04</td> <td>YES</td></tr>
                    <tr><td>Log::Dispatch::Config::TestLog</td><td>0.02</td> <td></td></tr>
                    <tr><td>Net::BitTorrent</td>               <td>0.052</td><td></td></tr>
                    <tr><td>Test::Able</td>                    <td>0.11</td> <td></td></tr>
                    <tr><td>Test::Aggregate</td>               <td>0.373</td><td></td></tr>
                    <tr><td>Test::Builder::Clutch</td>         <td>0.07</td> <td></td></tr>
                    <tr><td>Test::Dist::VersionSync</td>       <td>1.1.4</td><td></td></tr>
                    <tr><td>Test::Flatten</td>                 <td>0.11</td> <td></td></tr>
                    <tr><td>Test::Group</td>                   <td>0.20</td> <td></td></tr>
                    <tr><td>Test::Modern</td>                  <td>0.012</td><td></td></tr>
                    <tr><td>Test::More::Prefix</td>            <td>0.005</td><td>Maybe?</td></tr>
                    <tr><td>Test::ParallelSubtest</td>         <td>0.05</td> <td></td></tr>
                    <tr><td>Test::Pretty</td>                  <td>0.32</td> <td></td></tr>
                    <tr><td>Test::Wrapper</td>                 <td>0.3.0</td><td></td></tr>
                </table>
            </dd>
        </dl>
    </dd>
</dl>


