<dl class="listnav">
    <dt id="boilerplate">Boilerplate</dt>
    <dd>
        <h2>Boilerplate</h2>

        <br />
        <br />

        You should start by creating a test file. Typically these live in the
        t/ directory and end with the .t file extension.

        <br />
        <br />

        t/first_test.t:
        <script class="code">
            use Test2::Bundle::Extended;
        </script>

        <br />
        <br />

        <ul>
            <li>This loads Several plugins and toolsets.</li>
            <li>This is everything you need to get started.</li>
            <li>This is the bundle I recommend.</li>
            <li>This loads most of the tools and plugins used in this tutorial.</li>
            <li>This will fail until we add a plan and at least 1 assertion.</li>
        </ul>
    </dd>

    <dt id="Planning">Planning</dt>
    <dd>
        <dl class="sub_list">
            <dt id="why_plan">Why&nbsp;Plan?</dt>
            <dd>
                <h2>Why do I need a plan?</h2>

                <br />
                <p>

                <h3>A plan insures all tests run.</h3>

                <br />

                It is not impossible for a program to exit with code 0
                (success) before you think it will.

                <br />
                <p>

                A plan is a number of expected tests. If your test count and
                your plan do not match it will be considered a test failure.
            </dd>

            <dt id="counting">Counting</dt>
            <dd>
                <h2>Counting tests</h2>

                <p><br />

                The old way to set the plan was to count your tests, and specify that number.

                <p><br />

                Test2 does support this form:

                <script class="code">
                    use Test2::Bundle::Extended;

                    plan 5; # We expect 5 tests
                </script>

                <p><br />

                <ul>
                    <li>This form of planning is annoying.</li>
                    <li>Needs to be updated any time you change your test.</li>
                    <li>For long tests it can be hard to count.</li>
                    <li>Your test count might differ depending on outside factors.</li>
                </ul>
            </dd>

            <dt id="done_testing">done_testing</dt>
            <dd>
                <h2>done_testing()</h2>

                <br />

                A better (and newer) way to set the plan is to use done_testing.

                <br />

                <script class="code">
                    use Test2::Bundle::Extended;

                    ...

                    done_testing;
                </script>

                <br />

                <ul>
                    <li>Counts tests for you.</li>
                    <li>Does not need to be updated on every edit.</li>
                    <li>Really easy.</li>
                </ul>
            </dd>

            <dt id="skip_all">skip_all</dt>
            <dd>
                <h2>skip_all "..."</h2>

                <p><br />

                There are times where you might want to skip an entire test
                file. skip_all allows you to do this.

                <p><br />

                <script class="code">
                    use Test2::Bundle::Extended;

                    skip_all "Do not run on windows"
                        if $^O eq 'MSWin32';

                    my @time = localtime(time);
                    skip_all "Do not run on Tueseday"
                        if $time[6] == 2;
                </script>
            </dd>
        </dl>
    </dd>

    <dt id="Assertions">Assertions</dt>
    <dd>
        <h2>Assertions</h2>

        <p><br />

        The most simple assetions is ok().

        <p><br />

        <script class="code">
            use Test2::Bundle::Extended;

            ok(1, "This is a pass");
            ok(0, "This is a failure");

            ok(1 + 1 == 2, "Math works");

            done_testing;
        </script>

        <p><br />

        <ul>
            <li>First argument is a boolean expression.</li>
            <li>Second argument is an optinal description of the assertion.</li>
        </ul>
    </dd>

    <dt id="Todo">Todo</dt>
    <dd>
        <h2>Todo</h2>

        Sometimes you have tests that you want to pass, but for some reason do not yet.

        <p>

        You can use the todo() function for these:

        <p>

        You can call todo with a reason and a codeblock, the todo will apply
        only to the codeblock:

        <script class="code">
            $bool = 0;

            todo "foo" => sub {
                ok($bool, "Should be true");
            };

            # End of todo
        </script>

        If your code is sensitive to stack depth changes you can use a todo
        variable:

        <script class="code">
            $bool = 0;

            my $todo = todo "foo";

            ok($bool, "Should be true");

            $todo = undef; # End the todo
        </script>
    </dd>

    <dt id="References">References</dt>
    <dd>
        <h2>Assertions for references</h2>

        Setup:

        <script class="code">
            my $x = [1,2,3];
            my $y = [1,2,3];
            my $z = $x;
        </script>

        ref_ok() can check that something is a ref, or a ref of a specific type:
        <script class="code">
            ref_ok($y);
            ref_ok($x, 'ARRAY', '$x is an array');
        </script>

        ref_is() can check that 2 refs are the same exact ref:
        <script class="code">
            # Pass:
            ref_is($x, $z, '$x and $z are the same ref');
            ref_is($x, $y); # Fails, they are not the same ref
        </script>

        ref_is_not() is the opposite:
        <script class="code">
            # Pass:
            ref_is($x, $y, '$x and $y are not the same ref');
            ref_is($x, $z); # Fails, they are the same ref
        </script>
    </dd>

    <dt id="Comparisons">Comparisons</dt>
    <dd>
        <h2>Comparisons</h2>

        is() and like() can handle nearly all your comparison needs:

        <script class="code">
            # Shallow:
            is("apple", "apple", "strings are equivelent");
            like("apple", qr/ppl/, "string matches pattern");

            # And deep:
            is([1,2,3,4], [1,2,3,4], "arrays have the same contents");
            like([1,2,3,4], [1,2],   "first 2 array elements match");

            # Lets go deeper
            is(
                { a => 1, b => [1,2,3,4], c => 'cat' },
                { a => 1, b => [1,2,3,4], c => 'cat' },
                "Deep structure is a complete match"
            );

            # We only care a little:
            like(
                { a => 1, b => [1,2,3,4], c => 'cattle', d => "don't care" },
                { b => [1,2], c => qr/cat/ },
                "The parts we care about match"
            );

            # Right-side argument specifies the type for comparison:
            my $ref = [1,2,3];
            like($ref, "$ref", "String comparison is used");
        </script>
    </dd>

    <dt id="Compare_DSL">Compare&nbsp;DSL</dt>
    <dd>
        <dl class="sub_list">
            <dt id="State">State</dt>
            <dd>
                <h2>Simple state checks</h2>

                These are some shortcuts for checking the state of vars or nested elements.

                <script class="code">
                    # Loaded by default in Test2::Bundle::Extended
                    use Test2::Tools::Compare qw{ T F D DNE FDNE };

                    is(1, T(), "Check that we got a true value");
                    is(0, F(), "Check that we got a false value");
                    is(0, D(), "Check that we got a defined value");

                    is([1], [1, DNE()],  "Check that the second array element does not exist");
                    is({}, {a => DNE()}, "Check that the 'a' element does not exist");

                    is(
                        {a => 0},
                        {a => FDNE(), b => FDNE()},
                        "Check that a and b are false, or do not exist at all"
                    );
                </script>

                T() and F() may be used in nested structures, the key/element
                must exist, but may be undefined for F().
            </dd>

            <dt id="Directed">Directed</dt>
            <dd>
                <h2>Directed checks</h2>

                <p><br />

                You have some control over what type of check is used:

                <p><br />
                <script class="code">
                    # Loaded by default in Test2::Bundle::Extended
                    use Test2::Tools::Compare qw{ match mismatch number string exact_ref };

                    is("foo", match qr/oo/, "String matches pattern");

                    is("foo", mismatch qr/aa/, 'String does not match pattern');

                    is("12.00", number(12), "Use a numeric comparison");

                    is($thing, string($thing), "use a string comparison");

                    my $r = [];
                    is(
                        {a => $r},
                        {a => exact_ref($r)},
                        "ensure the 'a' key has the exact ref we want."
                    );
                </script>

                <p>

                <ul>
                    <li>These can all be nested as deep as you need.</li>
                    <li>They can be used in is() and like().</li>
                </ul>
            </dd>

            <dt id="Custom">Custom</dt>
            <dd>
                <h2>Custom validators</h2>

                <p><br />
                <script class="code">
                    # Loaded by default in Test2::Bundle::Extended
                    use Test2::Tools::Compare qw{ validator };

                    is(
                        "foo",
                        validator(sub { $_ eq 'foo' ? 1 : 0 }),
                        "Check that string is foo"
                    );

                    my $validator = validator(
                        "OP", "Check Foo",
                        sub {
                            my %params = @_;

                            my $got      = $params{got};         # Same as $_
                            my $exists   = $params{exists};      # Only applies to hash keys and array elements
                            my $operator = $params{operator};    # 'OP'
                            my $name     = $params{name};        # 'Check Foo'

                            ...

                            return $bool;
                        }
                    );
                </script>
            </dd>

            <dt id="Sets">Sets</dt>
            <dd>
                <h2>Checking sets</h2>

                <p><br />
                Check that the value matches 1 OR MORE of the specified checks.
                <script class="code">
                    is('apple', in_set('pear', 'apple', 'orange'), "got a fruit");
                </script>

                <p><br />
                Check that the value DOES NOT match ANY of the specified checks.
                <script class="code">
                    is('apple', not_in_set('dog', 'cat', 'cow'), "not an animal");
                </script>

                <p><br />
                Check that the value matches ALL of the specified checks.
                <script class="code">
                    is('apple', not_in_set(match qr/pp/, match qr/a/), "matched both patterns");
                </script>
            </dd>

            <dt id="Array">Array</dt>
            <dd>
                <h2>Array Checks</h2>

                <ul>
                    <li>Array checks let you declare an array.</li>
                </ul>

                <script class="code">
                    is(
                        [qw/foo bar baz bat/],
                        array {
                            item 'foo';        # [0] First item is 'foo'
                            item match qr/a/;  # [1] second item matches /a/
                            item 3 => 'bat';   # [3] Skip right to index 3
                            end;               # Specify that there should be no more items.
                        },
                        "Array matches expectations"
                    );
                </script>

                If we change the array, we can see how nice the diagnostics are:

                <script class="code">
                    [qw/bad oops/]
                </script>

                <script class="output">
                    not ok 1 - Array matches expectations
                    # Failed test 'Array matcheds expectations'
                    # at test.pl line 9.
                    # +------+------------------+----+---------+------+
                    # | PATH | GOT              | OP | CHECK   | LNs  |
                    # +------+------------------+----+---------+------+
                    # |      | ARRAY(0x850b58)  |    | <ARRAY> | 3, 8 |
                    # | [0]  | bad              | eq | foo     | 4    |
                    # | [1]  | oops             | =~ | (?^:a)  | 5    |
                    # | [3]  | <DOES NOT EXIST> |    | bat     | 6    |
                    # +------+------------------+----+---------+------+
                    1..1
                </script>
            </dd>

            <dt id="Hash">Hash</dt>
            <dd>
                <h2>Hash Checks</h2>

                <ul>
                    <li>Hash checks let you declare a hash.</li>
                </ul>

                <script class="code">
                    is(
                        {foo => 'foo', bar => 'bar'},
                        hash {
                            field foo => 'foo';
                            field bar => match qr/a/;
                            end; # Specify that there should be no more elements.
                        },
                        "Hash matches expectations"
                    );
                </script>

                If we change the hash, we can see how nice the diagnostics are:

                <script class="code">
                    {apple => 'butter', foo => 'foops', bar => 'buurr'}
                </script>

                <script class="output">
                    not ok 1 - Hash matches expectations
                    # Failed test 'Hash matches expectations'
                    # at test.pl line 8.
                    # +---------+-----------------+---------+------------------+------+
                    # | PATH    | GOT             | OP      | CHECK            | LNs  |
                    # +---------+-----------------+---------+------------------+------+
                    # |         | HASH(0x1ff7b58) |         | <HASH>           | 3, 7 |
                    # | {foo}   | foops           | eq      | foo              | 4    |
                    # | {bar}   | buurr           | =~      | (?^:a)           | 5    |
                    # | {apple} | butter          | !exists | <DOES NOT EXIST> |      |
                    # +---------+-----------------+---------+------------------+------+
                </script>
            </dd>

            <dt id="Meta">Meta</dt>
            <dd>
                <h2>Meta Checks</h2>

                <p>
                <br />
                Meta-checks give you the ability to check the properties of a
                value.

                <p>
                <br />
                <script class="code">
                    is(
                        $thing,
                        meta {
                            prop blessed => 'My::Module'; # Ensure value is blessed as our package
                            prop reftype => 'HASH';       # Ensure value is a blessed hash
                            prop size    => 4;            # Check the number of hash keys or array elements
                            prop this    => ...;          # Check the item itself
                        },
                        "Thing matches expectations"
                    );
                </script>

                <p>
                <br />
                meta() is a sub that takes a coderef as its only argument
                (prototype).

                <p>
                <br />

                The 4 properties above are available for any type of item.
                <br />
                <small>* Except size</small>
            </dd>

            <dt id="Object">Object</dt>
            <dd>
                <h2>Object checks</h2>
                <ul>
                    <li>Object checks let you declare an object.</li>
                    <li>Can use meta-check properties.</li>
                    <li>Can use hash or array depending on the object.</li>
                </ul>

                <script class="code">
                    is(
                        bless({foo => 'foo', bar => 'bar'}, 'My::Package'),
                        object {
                            # Meta properties:
                            prop blessed => 'My::Package';

                            # Can check fields on underlying hash
                            field foo => 'foo';
                            field bar => match qr/a/;

                            # Can check results of calling methods
                            call foo => 'foo';

                            # Can check results of calling custom methods
                            call sub {[shift->list]} => ['a', 'b', 'c'];
                        },
                        "Object is as expected"
                    );
                </script>
            </dd>
        </dl>
    </dd>

    <dt id="Class">Class</dt>
    <dd>
        <h2>Testing Classes</h2>

        <p>
        There are a couple useful tools for dealing with classes:
        <p>

        <script class="code">
            # This loads My::Class (but does not import it)
            use Test2::Bundle::Extended -target => 'My::Class';

            # These are imported for you:
            say $CLASS;  # prints "My::Class"
            say CLASS(); # prints "My::Class"

            my $one = CLASS->new(...);

            # This is different from Test:More
            isa_ok($one, 'My::Class', 'Parent::Class', ...);

            # Same as Test::More
            can_ok($one, qw/foo bar baz/);

            # New
            DOES_ok($one, 'Some::Thing', 'Some::Thing::Else');
        </script>

        <p>
        <ul>
            <li>target is provided by Test2::Tools::Target</li>
            <li>isa_ok, can_ok, and DOES_ok are provided by Test2::Tools::Class</li>
        </ul>
    </dd>

    <dt id="Helpers">Helpers</dt>
    <dd>
        <h2>Writing helpers and wrappers</h2>

        Sometimes you want to encapsulate a sequence of testing tools for re-use:

        <script class="code">
            sub verify_thing {
                my ($thing) = @_;

                # Get context
                my $ctx = context();

                ok($thing, "Got a thing");
                isa_ok($thing, 'Thing');
                like($thing->foo, qr/xxx/, "foo has xxx");

                # Release the context
                $ctx->release;

                return;
            }
        </script>

        <ul>
            <li>All tools aquire a context</li>
            <li>Tools find an existing context if present</li>
            <li>Context is what tracks file/line number for error reporting</li>
            <li>You MUST release a context when done with it.</li>
        </ul>
    </dd>

    <dt id="Subtests">Subtests</dt>
    <dd>
        <h2>Writing Subtests</h2>

        <script class="code">
            subtest foo => sub {
                ok(1, 'a');
                ok(1, 'b');
            };
        </script>

        There are 2 flavors of subtest, The extended bundle provides Buffered:

        <script class="output">
            ok 1 - foo {
                ok 1 - a
                ok 2 - b
                1..2
            }
        </script>

        The alternative is streamed, this is what Test::More provided:

        <script class="output">
            # Subtest: foo
                ok 1 - a
                ok 2 - b
                1..2
            ok 1 - foo
        </script>
    </dd>

    <dt id="Trapping">Trapping</dt>
    <dd>
        <h2>Trapping Things</h2>

        You can capture exceptions and warnings for use in tests:

        <script class="code">
            ok(lives { ... }, "Code did not die");

            like(
                dies { die "xxx" },
                qr/xxx/,
                "got expected exception"
            );

            ok(warns { warn "xxx" }, "got at least 1 warning");
            ok(no_warnings { ... }, "got no warnings");

            like(
                warning { warn "xxx" },
                qr/xxx/,
                "Got exactly 1 warning that matches regex"
            );

            like(
                warnings { warn "xxx"; warn "yyy" },
                [qr/xxx/, qr/yyy/],
                "Got both expected warnings"
            );
        </script>

        These follow the lessons learned by previous tools.
    </dd>

    <dt id="Mocking">Mocking</dt>
    <dd>
        <h2>Test2::Tools::Mock</h2>

        The mock() function is your one-stop shop for all mocking.
        <p>
        You can mock classes:
        <script class="code">
            my $mock = mock 'Some::Package' => (
                add      => [foo => sub { 'foo' }],
                override => [bar => sub { 'bar' }],
            );

            Some::Package->foo;
            Some::Package->bar;

            $mock = undef;
            # No more mock.
        </script>

        You can mock objects:
        <script class="code">
            my $obj = mock {bar => 1} => (
                add => [foo => sub { 'foo' }],
            );

            $obj->foo;
            $obj->bar;

            $obj->baz(1); # baz() is vivified for you as a getter/setter
        </script>

    </dd>

    <dt id="On_Fail">On&nbsp;Fail</dt>
    <dd>
        <h1>On Fail</h1>

        Die On Fail:
        <script class="code">
            use Test2::Plugin::DieOnFail;

            ok(0, 'failed'); # dies here
        </script>

        <p>
        Bail On Fail:
        <script class="code">
            use Test2::Plugin::BailOnFail;

            ok(0, 'failed'); # bail-out here
        </script>

        <p>
        <ul>
            <li>One of the most requested features for several years.</li>
            <li>No good way to do it with legacy Test::Builder</li>
            <li>Easy with Test2</li>
        </ul>
    </dd>

    <dt id="SPEC">SPEC</dt>
    <dd>
        <dl class="sub_list">
            <dt id="test_blocks">test&nbsp;blocks</dt>
            <dd>
                <h2>Test Blocks</h2>

                <script class="code">
                    use Test2::Bundle::Extended;
                    use Test2::Tools::Spec; # Not loaded by bundle

                    tests foo => sub {
                        ok(1, "pass");
                    };

                    tests bar => sub {
                        ok(1, "pass");
                    };

                    tests bad => {todo => 'This block is todo'}, sub {
                        ok(0, "fail");
                    };

                    tests very_bad => {skip => 'this will rm -rf /'}, sub {
                        # This will not run.
                        system('rm -rf /');
                    };

                    done_testing;
                </script>

                The most basic unit in the SPEC tools is 'tests'. This function
                takes a name, and a codeblock to run.
                <p>
                Test blocks are not run immedietly, they will be run when the
                done_testing() function is called.
            </dd>

            <dt id="params">params</dt>
            <dd>
                <h2>Attributes</h2>

                <script class="code">
                    tests a => {flat => 1           }, sub { ... };
                    tests b => {todo => "fix later" }, sub { ... };
                    tests c => {skip => "do not run"}, sub { ... };
                    tests d => {iso => 1            }, sub { ... };
                    tests e => {async => 1          }, sub { ... };
                </script>

                <table>
                    <tr><th>Parameter</th><th>Default</th><th>Description</th></tr>
                    <tr><td>flat </td><td>0</td><td>Do not render block as a subtest</td></tr>
                    <tr><td>todo </td><td>undef</td><td>Mark entire block as TODO</td></tr>
                    <tr><td>skip </td><td>undef</td><td>Do not run the block, generate skip event</td></tr>
                    <tr><td>iso  </td><td>0</td><td>Isolate test by forking or spawning a new thread</td></tr>
                    <tr><td>async</td><td>0</td><td>Test can be run concurrently (but does not have to be)</td></tr>
                </table>

                <p>

                You can combine any number of these at once.

                <script class="code">
                    tests foo => {flat => 1, iso => 1, async => 1}, sub {
                        ...
                    }
                </script>
            </dd>

            <dt id="Describe">Describe</dt>
            <dd>
                <h2>Describe Blocks</h2>

                Describe blocks are a way of grouping test blocks together
                along with any setup and teardown.

                <script class="code">
                    describe color => sub {
                        tests red   => sub { ... };
                        tests green => sub { ... };
                        tests blue  => sub { ... };
                    };

                    describe size => sub {
                        tests small  => sub { ... };
                        tests medium => sub { ... };
                        tests large  => sub { ... };

                        # Nestable
                        describe nested => sub { ... };
                    };
                </script>
            </dd>

            <dt id="wf_before">Before</dt>
            <dd>
                <h2>Before</h2>

                <script class="code">
                    before_all  outer1 => sub { ... };
                    before_each outer2 => sub { ... };

                    describe color => sub {
                        before_all  inner1 => sub { ... };
                        before_each inner2 => sub { ... };

                        tests red   => sub { ... };
                        tests green => sub { ... };
                        tests blue  => sub { ... };

                        describe nested => { ... };
                    };

                    tests not_color => sub { ... };
                </script>

                <ul>
                    <li>outer1 will run once, before anything else</li>
                    <li>outer2 will run once per test block, before the test block</li>
                    <li>outer2 runs for 'not_color', 'red', 'green', and 'blue'</li>
                    <li>inner1 will run once, before 'red', 'green', and 'blue'</li>
                    <li>inner2 will run once per test block, before the block</li>
                    <li>inner2 does not run for 'not_color'</li>
                    <li>inner2 will run for any tests under 'nested'</li>
                </ul>
            </dd>

            <dt id="after">After</dt>
            <dd>
                <h2>After</h2>

                <script class="code">
                    after_all  outer1 => sub { ... };
                    after_each outer2 => sub { ... };

                    describe color => sub {
                        after_all  inner1 => sub { ... };
                        after_each inner2 => sub { ... };

                        tests red   => sub { ... };
                        tests green => sub { ... };
                        tests blue  => sub { ... };

                        describe nested => { ... };
                    };

                    tests not_color => sub { ... };
                </script>

                <ul>
                    <li>outer1 will run once, after everything else</li>
                    <li>outer2 will run once per test block, after the test block</li>
                    <li>outer2 runs for 'not_color', 'red', 'green', and 'blue'</li>
                    <li>inner1 will run once, after 'red', 'green', and 'blue'</li>
                    <li>inner2 will run once per test block, after the block</li>
                    <li>inner2 does not run for 'not_color'</li>
                    <li>inner2 will run for any tests under 'nested'</li>
                </ul>
            </dd>

            <dt id="Around">Around</dt>
            <dd>
                <h2>Around</h2>

                <p>

                <script class="code">
                    around_all foo => sub {
                        my $continue = shift;
                        ...
                        $continue->();
                        ...
                    };

                    around_each bar => sub {
                        my $continue = shift;
                        ...
                        $continue->();
                        ...
                    };
                </script>

                <ul>
                    <li>Same rules as before/after.</li>
                    <li>You MUST call the $continue sub.</li>
                    <li>Useful for localizing environment variables.</li>
                </ul>
            </dd>

            <dt id="Cases">Cases</dt>
            <dd>
                <h2>Test Cases</h2>

                <script class="code">
                    describe color_validator => {flat => 1}, sub {
                        my $c;
                        case red   => sub { $c = 'red'   };
                        case green => sub { $c = 'green' };
                        case blue  => sub { $c = 'blue'  };

                        tests validator => {flat => 1}, sub {
                            ok(is_valid_color($c), "$c is a color");
                        }

                        tests visible => {flat => 1}, sub {
                            ok(is_visible($c), "$c is visible");
                        }
                    };
                </script>

                Output:
                <script class="output">
                    ok 1 - red {
                        ok 1 - red is a color
                        1..1
                    }
                    ok 2 - blue {
                        ok 1 - blue is a color
                        1..1
                    }
                    ok 3 - green {
                        ok 1 - green is a color
                        1..1
                    }
                    1..3
                </script>

            </dd>

            <dt id="mod_case">Case&nbsp;Mods</dt>
            <dd>
                <h2>Case Modifiers</h2>

                <script class="code">
                    case a => { ... };
                    case b => { ... };

                    before_case foo => sub { ... };
                    after_case  bar => sub { ... };

                    around_case baz => sub { ...; $_[0]->(); ... };
                </script>

                <ul>
                    <li>These work just like before/after do with test blocks</li>
                    <li>These bind to the cases instead of the test blocks</li>
                </ul>

                Order of execution:
                <ol>
                    <li>before_all</li>
                    <li>
                        (for each case)
                        <ol>
                            <li>before_case</li>
                            <li>case</li>
                            <li>after_case</li>
                            <li>
                                (for each test block)
                                <ol>
                                    <li>before_each</li>
                                    <li>tests</li>
                                    <li>after_each</li>
                                </ol>
                            </li>
                        </ol>
                    </li>
                    <li>after_all</li>
                </ol>
            </dd>

            <dt id="Mocking">Mocking</dt>
            <dd>
                <h2>Mocking</h2>

                <p>

                Test2::Tools::Spec is smart with Test2::Tools::Mock. It treats
                a mock in void context as a before_each (roughly).

                <p>

                <script class="code">
                    describe stuff => sub {
                        mock Foo::Bar => ( ... );
                        # Mock is active, no need to capture the control object

                        before_each => sub {
                            # Mock is active
                        }

                        tests foo => sub {
                            # Mock is active
                        };

                        after_each => sub {
                            # Mock is active
                        }
                    };
                    # Mock is not active

                    tests bar => sub {
                        # Mock is not active
                    };
                </script>
            </dd>

            <dt id="Declare">Declare</dt>
            <dd>
                <h2>Declare</h2>

                <p>

                Test2::Plugin::SpecDeclare provides nice syntax sugar:

                <p>

                <script class="code">
                    use Test2::Bundle::Extended;
                    use Test2::Tools::Spec;
                    use Test2::Plugin::SpecDeclare;

                    describe foo(flat => 1) {
                        tests bar(iso => 1) {
                            ...
                        }

                        before_each setup    { ... }
                        after_each  teardown { ... }

                        case red { ... }
                    }
                </script>

                <ul>
                    <li>No need for 'sub' keyword.</li>
                    <li>No need for ending semicolon.</li>
                    <li>Parameters are like a signature.</li>
                    <li>Uses Devel::Declare.</li>
                </ul>
            </dd>
        </dl>
    </dd>
</dl>
